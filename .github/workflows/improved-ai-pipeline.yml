name: AI Article Generation & Publishing Pipeline - Quality Enhanced

on:
  schedule:
    - cron: '15 */4 * * *'  # Every 4 hours
  workflow_dispatch:

jobs:
  generate-and-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Sync with latest changes
        run: |
          echo "ğŸ”„ Syncing with latest remote changes..."
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull origin main || echo "âš ï¸ No remote changes to pull"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          npm install -g @google/gemini-cli textlint textlint-rule-preset-japanese textlint-rule-preset-ja-technical-writing @textlint-ja/textlint-rule-preset-ai-writing
          pip install sentence-transformers scikit-learn numpy requests pillow
          mkdir -p _temp _posts assets/images/posts scripts

      # STAGE 1: Simplified and Reliable Topic Generation
      - name: Generate high-quality topics
        shell: bash
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          export GEMINI_API_KEY="$GEMINI_API_KEY"
          
          echo "ğŸ¯ Generating focused AI topics..."

          # API key verification
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "âŒ GEMINI_API_KEY is not set"
            exit 1
          fi
          
          # Simple and reliable topic generation prompt
          # Enhanced topic prompt with diversity focus and recent content filtering
          RECENT_TITLES=$(find _posts -name "$(date +%Y-%m)*" -exec basename {} \; 2>/dev/null | head -10 | tr '\n' ' ')
          TOPIC_PROMPT="WebSearch: AIæ¥­ç•Œ æœ€æ–°ãƒ‹ãƒ¥ãƒ¼ã‚¹ $(date '+%Yå¹´%mæœˆ%dæ—¥'). ã€é‡è¦ã€‘éå»è¨˜äº‹ã¨ã®é‡è¤‡ã‚’é¿ã‘ã€ä»¥ä¸‹ã®æœ€è¿‘ã®ã‚¿ã‚¤ãƒˆãƒ«ã¨ç•°ãªã‚‹æ–°ã—ã„è©±é¡Œã‚’ç”Ÿæˆ: $RECENT_TITLES ã€è¦æ±‚ã€‘AIæ¥­ç•Œã®æœ€æ–°ãƒ»ç‹¬è‡ªè©±é¡Œã‚’3å€‹ç”Ÿæˆã€‚ã€å¿…é ˆæ¡ä»¶ã€‘1. ç•°ãªã‚‹ä¼æ¥­ãƒ»åˆ†é‡ãƒ»è§’åº¦ã‹ã‚‰é¸æŠï¼ˆOpenAIã€NVIDIAã€Googleã€Microsoftã€Metaã€Amazonã€Appleã€Anthropicã€ä¸­å›½AIä¼æ¥­ã€æ–°èˆˆä¼æ¥­ã€è¦åˆ¶ãƒ»æ”¿ç­–ã€æ¥­ç•Œå‹•å‘ç­‰ï¼‰ 2. å…·ä½“çš„ãªä¼æ¥­åãƒ»è£½å“åãƒ»æ•°å€¤ã‚’å«ã‚€ 3. 30æ–‡å­—ä»¥å†…ã®ã‚¿ã‚¤ãƒˆãƒ« 4. æŠ•è³‡å®¶ãƒ»æŠ€è¡“è€…ãŒé–¢å¿ƒã‚’æŒã¤å†…å®¹ 5. ç•ªå·ä»˜ããƒªã‚¹ãƒˆå½¢å¼ ã€å¤šæ§˜æ€§é‡è¦–ã€‘åŒã˜ä¼æ¥­ãƒ»åŒã˜ãƒˆãƒ”ãƒƒã‚¯ï¼ˆGPTã€NVIDIAç­‰ï¼‰ã®é‡è¤‡ã‚’é¿ã‘ã‚‹ã€‚ã€å‡ºåŠ›ä¾‹ã€‘1. Anthropic Claude 3.5ã€ã‚³ãƒ¼ãƒ‰ç”Ÿæˆç²¾åº¦40%å‘ä¸Š 2. ä¸­å›½ByteDanceã€AIå‹•ç”»ç”Ÿæˆã§ç±³å›½é€²å‡º 3. EU AIæ³•æ–½è¡Œã€ä¼æ¥­ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å¯¾å¿œæ€¥å‹™"

          # Enhanced API call with comprehensive validation
          echo "ğŸ”„ Attempting topic generation (with retry)..."
          TOPIC_GENERATION_SUCCESS=false
          
          for api_retry in 1 2; do
            echo "ğŸ“¡ API attempt $api_retry for topic generation"

            if gemini -m "gemini-2.5-flash-lite" -p "$TOPIC_PROMPT" > _temp/topics.txt 2>_temp/topic_generation_error.log; then
              echo "âœ… API call completed successfully"
              
              # Comprehensive content validation
              if [ -s "_temp/topics.txt" ]; then
                echo "ğŸ“„ Topics file created with content:"
                cat _temp/topics.txt
                
                # Check for error messages in response
                if grep -qi "error\|failed\|unable\|quota\|limit" _temp/topics.txt 2>/dev/null; then
                  echo "âš ï¸ API response contains error messages"
                  echo "Response content:"
                  cat _temp/topics.txt
                else
                  # Safe topic counting with file existence check
                  TOPIC_COUNT=0
                  if [ -s "_temp/topics.txt" ]; then
                    TOPIC_COUNT=$(grep -c "^[0-9]\+\." _temp/topics.txt 2>/dev/null || echo "0")
                  fi
                  
                  # Validate topic count is a number and > 0
                  if [[ "$TOPIC_COUNT" =~ ^[0-9]+$ ]] && [ "$TOPIC_COUNT" -gt 0 ]; then
                    echo "ğŸ“Š Generated $TOPIC_COUNT valid topics"
                    TOPIC_GENERATION_SUCCESS=true
                    break
                  else
                    echo "âš ï¸ No valid numbered topics found in response"
                    echo "Expected format: '1. Topic title'"
                  fi
                fi
              else
                echo "âŒ Topics file is empty or not created"
                if [ -f "_temp/topic_generation_error.log" ]; then
                  echo "Error log:"
                  cat _temp/topic_generation_error.log
                fi
              fi
            else
              echo "âŒ API call failed with exit code $?"
              if [ -f "_temp/topic_generation_error.log" ]; then
                echo "Error details:"
                cat _temp/topic_generation_error.log
              fi
            fi
            
            if [ "$TOPIC_GENERATION_SUCCESS" = "false" ] && [ "$api_retry" -lt 2 ]; then
              echo "ğŸ”„ Retrying in 15 seconds..."
              sleep 15
            fi
          done
          
          if [ "$TOPIC_GENERATION_SUCCESS" = "false" ]; then
            echo "âŒ Failed to generate valid topics after 2 attempts"
            echo "ğŸ”§ Attempting fallback with simpler prompt..."
            
            # Fallback with simpler prompt
            SIMPLE_PROMPT="Generate 3 AI industry news topics in this format: 1. Topic 2. Topic 3. Topic. Each topic should be under 30 characters and mention specific companies."
            
            if gemini -m "gemini-2.5-flash-lite" -p "$SIMPLE_PROMPT" > _temp/topics_fallback.txt 2>/dev/null; then
              if [ -s "_temp/topics_fallback.txt" ]; then
                mv _temp/topics_fallback.txt _temp/topics.txt
                echo "âœ… Fallback topics generated"
                cat _temp/topics.txt
              fi
            fi
            
            # Final validation
            FINAL_TOPIC_COUNT=0
            if [ -s "_temp/topics.txt" ]; then
              FINAL_TOPIC_COUNT=$(grep -c "^[0-9]\+\." _temp/topics.txt 2>/dev/null || echo "0")
            fi
            
            if [[ "$FINAL_TOPIC_COUNT" =~ ^[0-9]+$ ]] && [ "$FINAL_TOPIC_COUNT" -gt 0 ]; then
              echo "ğŸ“Š Final validation: $FINAL_TOPIC_COUNT topics available"
            else
              echo "ğŸ’€ Complete failure: No valid topics could be generated"
              exit 1
            fi
          fi

      # STAGE 2: Quality-Focused Article Generation  
      - name: Generate high-quality articles
        shell: bash
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "ğŸ“ Generating professional articles..."
          
          # Extract topics and save as temp files for duplicate checking
          grep -E "^[0-9]+\." _temp/topics.txt | head -3 > _temp/selected_topics.txt
          
          # Debug: Show extracted topics
          echo "ğŸ“‹ Extracted topics for processing:"
          cat _temp/selected_topics.txt
          AVAILABLE_TOPICS=$(wc -l < _temp/selected_topics.txt)
          echo "ğŸ“Š Available topics: $AVAILABLE_TOPICS"
          
          # Prepare existing titles for duplicate checking
          echo "ğŸ” Preparing duplicate check data..."
          find _posts -name "*.md" -mtime -3 | head -20 | while read -r post; do
            if [ -f "$post" ]; then
              grep "^title:" "$post" 2>/dev/null || true
            fi
          done > _temp/existing_titles.txt || true
          
          echo "ğŸ“ Existing titles for duplicate checking:"
          head -5 _temp/existing_titles.txt || echo "No existing titles found"
          
          # Use robust for-loop instead of while-loop to ensure all topics are processed
          GENERATED_COUNT=0
          FAILED_COUNT=0
          
          for topic_number in 1 2 3; do
            TOPIC_LINE=$(sed -n "${topic_number}p" _temp/selected_topics.txt 2>/dev/null)
            
            if [ -z "$TOPIC_LINE" ]; then
              echo "âš ï¸ No topic found at position $topic_number"
              continue
            fi
            
            TOPIC=$(echo "$TOPIC_LINE" | sed 's/^[0-9]*\. *//')
            echo "ğŸ“ Processing topic $topic_number: $TOPIC"
            
            # Enhanced article generation prompt with completion safeguards
            ARTICLE_PROMPT="WebSearch: $TOPIC è©³ç´°æƒ…å ± ä¼æ¥­ æŠ•è³‡ æŠ€è¡“. ã‚ãªãŸã¯ã€AIæ¥­ç•Œã‚’20å¹´é–“ã‚¦ã‚©ãƒƒãƒã—ç¶šã‘ã¦ããŸã€çµŒé¨“è±Šå¯Œãªãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ãƒ»ã‚¢ãƒŠãƒªã‚¹ãƒˆã§ã™ã€‚ã‚·ãƒªã‚³ãƒ³ãƒãƒ¬ãƒ¼ã®ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã‹ã‚‰æ—¥æœ¬ã®å¤§ä¼æ¥­ã¾ã§ã€æ•°ç™¾ç¤¾ã®AIå°å…¥ã‚’é–“è¿‘ã§è¦‹ã¦ãã¾ã—ãŸã€‚æŠ€è¡“ã®æœ¬è³ªã‚’è¦‹æŠœãæ´å¯ŸåŠ›ã¨ã€è¤‡é›‘ãªæŠ€è¡“å‹•å‘ã‚’æŠ•è³‡å®¶ã‚„æŠ€è¡“è€…ã«ã¨ã£ã¦ä½¿ãˆã‚‹æƒ…å ±ã«å¤‰æ›ã™ã‚‹èƒ½åŠ›ãŒå¼·ã¿ã§ã™ã€‚ã‚ãªãŸã¯æ±ºã—ã¦å®Œç’§ã§ã¯ãªãã€æ™‚ã«ã¯äºˆæ¸¬ã‚’å¤–ã™ã“ã¨ã‚‚ã‚ã‚Šã€æ–°ã—ã„æŠ€è¡“ã«å¯¾ã—ã¦æœ€åˆã¯æ‡ç–‘çš„ã«ãªã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ã—ã‹ã—ã€ãã®æ…é‡ã•ãŒåˆ†æã«ä¿¡é ¼æ€§ã‚’ã‚‚ãŸã‚‰ã—ã¦ã„ã¾ã™ã€‚ã€æ–‡ä½“æŒ‡ç¤ºã€‘è¦ªã—ã¿ã‚„ã™ãå°‚é–€çš„ã€‚æ¥­ç•Œã®å…ˆè¼©ãŒå¾Œè¼©ã«ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã™ã‚‹ã‚ˆã†ãªæ¸©ã‹ã¿ã®ã‚ã‚‹èªã‚Šã‹ã‘ã§æ›¸ã„ã¦ãã ã•ã„ã€‚çŸ­ã„æ–‡ã§æ³¨æ„ã‚’å¼•ãã€é•·ã„æ–‡ã§è©³ã—ãèª¬æ˜ã™ã‚‹ãƒªã‚ºãƒ ã‚’æ„è­˜ã—ã€èª­è€…ã«ç›´æ¥è©±ã—ã‹ã‘ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆã‚ãªãŸã‚‚æ„Ÿã˜ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€æ­£ç›´ãªã¨ã“ã‚ã€å€‹äººçš„ã«ã¯ç­‰ï¼‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚ã€æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã€‘1.æœ€åˆã®å°è±¡ã‚’ç‡ç›´ã«è¿°ã¹ã‚‹ 2.éå»ã®çµŒé¨“ã¨ç…§ã‚‰ã—åˆã‚ã›ã‚‹ 3.ç–‘å•ã‚„æ‡¸å¿µã‚’è¡¨ç¾ 4.è¤‡æ•°ã®è¦–ç‚¹ã‚’æ¤œè¨ 5.è‡ªåˆ†ãªã‚Šã®çµè«–ã«è‡³ã‚‹ã€é¿ã‘ã‚‹ã“ã¨ã€‘çµè«–ã¨ã—ã¦ã€ç•™æ„ã™ã¹ãé‡è¦ãªç‚¹ã¯ç­‰ã®å¸¸å¥—å¥ã€äºˆæ¸¬ã•ã‚Œã¾ã™ã®å¤šç”¨ã€å®Œç’§ã™ãã‚‹è«–ç†æ§‹æˆã€ç®‡æ¡æ›¸ãã®å¤šç”¨ã€è¨˜äº‹æ§‹æˆã€‘å›ºå®šçš„ãªæ¦‚è¦â†’è©³ç´°åˆ†æâ†’å¸‚å ´å½±éŸ¿â†’å±•æœ›ã§ã¯ãªãã€è‡ªç„¶ãªæµã‚Œã§ï¼š1.å°è±¡çš„ãªå°å…¥ï¼ˆæœ€åˆã®åå¿œã€èª­è€…ã¸ã®å•ã„ã‹ã‘ï¼‰2.èƒŒæ™¯èª¬æ˜ï¼ˆé‡è¦æ€§ã€çµŒé¨“è«‡ï¼‰3.æ ¸å¿ƒåˆ†æï¼ˆæŠ€è¡“ãƒ»ãƒ“ã‚¸ãƒã‚¹è©³ç´°ã€æ•°å€¤ãƒ‡ãƒ¼ã‚¿ï¼‰4.å®Ÿè·µçš„ç¤ºå”†ï¼ˆæŠ•è³‡å®¶ãƒ»æŠ€è¡“è€…ãŒä½•ã‚’ã™ã¹ãã‹ï¼‰5.é–‹ã‹ã‚ŒãŸçµã³ï¼ˆæ€è€ƒã‚’ä¿ƒã™å•ã„ã‹ã‘ã§çµ‚ã‚ã‚‹ï¼‰ã€å®Œæˆåº¦ä¿è¨¼ã€‘è¨˜äº‹ã¯å¿…ãšå®Œçµã•ã›ã‚‹ã“ã¨ã€‚æ–‡ç« ã®é€”ä¸­ã§çµ‚ã‚ã‚‹ã“ã¨ã¯çµ¶å¯¾ã«é¿ã‘ã€ã™ã¹ã¦ã®æ®µè½ãŒé©åˆ‡ãªå¥èª­ç‚¹ã§å®Œçµã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ç‰¹ã«æœ€å¾Œã®æ®µè½ã¯èª­è€…ã¸ã®å•ã„ã‹ã‘ã¨å€‹äººçš„è¦‹è§£ã§è‡ªç„¶ã«ç· ã‚ããã‚‹ã“ã¨ã€‚ã€ã‚¿ã‚¹ã‚¯ã€‘$TOPICã«ã¤ã„ã¦ä¸Šè¨˜ãƒšãƒ«ã‚½ãƒŠã§3000-4000æ–‡å­—ã®è¨˜äº‹ã‚’ä½œæˆã€‚ã‚¿ã‚¤ãƒˆãƒ«ã¯40æ–‡å­—ç¨‹åº¦ã§å¥½å¥‡å¿ƒã‚’åˆºæ¿€ã™ã‚‹ã‚‚ã®ï¼ˆè¡æ’ƒã€å¤‰ãˆã‚‹æœªæ¥ç­‰ã®ç…½ã‚Šæ–‡å¥ã§ãªãã€ãã®çœŸæ„ã¯ï¼Ÿã€ä½•ãŒå¤‰ã‚ã‚‹ã®ã‹ï¼Ÿç­‰ã®æ€è€ƒã‚’ä¿ƒã™ã‚¿ã‚¤ãƒˆãƒ«ï¼‰ã€‚ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…ãšå®Œå…¨ãªæ–‡ã¨ã—ã¦çµ‚ã‚ã‚‰ã›ã€é€”ä¸­ã§åˆ‡ã‚Œã‚‹ã“ã¨ãŒãªã„ã‚ˆã†æ³¨æ„ã—ã¦ãã ã•ã„ã€‚è¨˜äº‹æœ«å°¾ã«---END---ã‚’å¿…ãšè¨˜è¼‰ã€‚ã€é‡è¦ï¼šã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ç¶²ç¾…æ€§è¦ä»¶ã€‘è¨˜äº‹ä¸»é¡Œã«é–¢é€£ã™ã‚‹å…·ä½“çš„ãªæŠ€è¡“åã€è£½å“åã€ã‚µãƒ¼ãƒ“ã‚¹åã€ä¼æ¥­åã€ææºå…ˆã€å›½éš›ä¼šè­°åç­‰ã‚’Webæ¤œç´¢çµæœã‹ã‚‰å¯èƒ½ãªé™ã‚ŠæŠ½å‡ºã—ã€ä¸è‡ªç„¶ã«ãªã‚‰ãªã„å½¢ã§æœ¬æ–‡ä¸­ã«ç››ã‚Šè¾¼ã‚€ã“ã¨ã€‚ç‰¹ã«é‡è¦ãªå›ºæœ‰åè©ï¼ˆæŠ€è¡“ãƒ»ã‚µãƒ¼ãƒ“ã‚¹åã€ä¼æ¥­ãƒ»å›£ä½“åã€è¦æ ¼ãƒ»ä¼šè­°åï¼‰ã¯ç‰©èªã®æµã‚Œã‚’å£Šã•ãªã„ç¯„å›²ã§ç©æ¥µçš„ã«è¨€åŠã—ã€å˜ãªã‚‹ç¾…åˆ—ã§ã¯ãªããã‚ŒãŒç‰©èªã®ä¸­ã§ã©ã®ã‚ˆã†ãªæ„å‘³ã‚’æŒã¤ã‹ã‚’ç°¡æ½”ã«è§£èª¬ã™ã‚‹ã“ã¨ã€‚ã€æœ€çµ‚ãƒã‚§ãƒƒã‚¯ã€‘èª­è€…ã¸ã®å•ã„ã‹ã‘2å›ä»¥ä¸Šã€å€‹äººçš„è¦‹è§£ãƒ»çµŒé¨“å«æœ‰ã€å®Œç’§ã™ããªã„æ§‹æˆï¼ˆäººé–“ã‚‰ã—ã„ä¸å®Œå…¨ã•ï¼‰ã€è¦ªã—ã¿ã‚„ã™ã•ã®ç¢ºä¿ã€é‡è¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®è‡ªç„¶ãªæ–‡è„ˆã§ã®ç¶²ç¾…ã€è¨˜äº‹ã®å®Œå…¨æ€§ï¼ˆæ–‡ç« ãŒé€”åˆ‡ã‚Œã¦ã„ãªã„ã“ã¨ï¼‰ã€‚"

            # Generate article with improved error handling
            GENERATION_SUCCESS=false
            for retry in 1 2; do
              echo "ğŸ“ API attempt $retry for topic $topic_number"
              if gemini -m "gemini-2.5-flash-lite" -p "$ARTICLE_PROMPT" > "_temp/raw-article-${topic_number}.md" 2>_temp/api_error_${topic_number}.log; then
                echo "âœ… API call successful for topic $topic_number"
                GENERATION_SUCCESS=true
                break
              else
                echo "âš ï¸ API attempt $retry failed for topic $topic_number, checking error..."
                if [ -f "_temp/api_error_${topic_number}.log" ]; then
                  echo "Error log content:"
                  cat _temp/api_error_${topic_number}.log
                fi
                
                if grep -q "503\|UNAVAILABLE\|overloaded" _temp/api_error_${topic_number}.log 2>/dev/null; then
                  echo "ğŸ”„ API overloaded (503), waiting 30s before retry..."
                  sleep 30
                elif grep -q "429\|quota" _temp/api_error_${topic_number}.log 2>/dev/null; then
                  echo "ğŸš« API quota exceeded, will continue with next topic"
                  break
                else
                  echo "âš ï¸ Other API error, will continue with next topic"
                  if [ "$retry" -eq 2 ]; then
                    break
                  fi
                fi
              fi
            done
            
            if [ "$GENERATION_SUCCESS" = "true" ]; then
              # Enhanced quality and completion checks
              ARTICLE_FILE="_temp/raw-article-${topic_number}.md"
              QUALITY_ISSUES=""
              
              # Check for END marker
              if ! grep -q -- "---END---" "$ARTICLE_FILE"; then
                echo "âš ï¸ Article $topic_number missing ---END--- marker"
                QUALITY_ISSUES="${QUALITY_ISSUES}no_end_marker "
              fi
              
              # Check article length (should be 3000-4000 characters)
              ARTICLE_LENGTH=$(wc -c < "$ARTICLE_FILE")
              if [ "$ARTICLE_LENGTH" -lt 2000 ]; then
                echo "âš ï¸ Article $topic_number too short: ${ARTICLE_LENGTH} characters"
                QUALITY_ISSUES="${QUALITY_ISSUES}too_short "
              fi
              
              # Check for incomplete sentences (ending with incomplete words)
              LAST_LINE=$(tail -n 10 "$ARTICLE_FILE" | grep -v "^---END---" | tail -n 1)
              if echo "$LAST_LINE" | grep -E "[ã€]$|[æ®µã‚¨ã¨ã‹ãŒã¦ã§ã«ã¯ã‚’ã®ã‚‚ã—ã¾ãŸã‚Š]$" >/dev/null; then
                echo "âš ï¸ Article $topic_number may have incomplete ending: $LAST_LINE"
                QUALITY_ISSUES="${QUALITY_ISSUES}incomplete_ending "
              fi
              
              # Check for proper conclusion
              if ! grep -E "(å€‹äººçš„ã«ã¯|ã‚ãªãŸã¯ã©ã†|æœŸå¾…ã—ã¦ã„|è€ƒãˆã¦ã„)" "$ARTICLE_FILE" >/dev/null; then
                echo "âš ï¸ Article $topic_number may lack personal conclusion"
                QUALITY_ISSUES="${QUALITY_ISSUES}no_conclusion "
              fi
              
              if [ -n "$QUALITY_ISSUES" ]; then
                echo "ğŸ“ Article $topic_number quality issues: $QUALITY_ISSUES"
              else
                echo "âœ… Article $topic_number passed quality checks"
              fi
              
              # Title extraction and validation
              RAW_TITLE=$(head -1 "_temp/raw-article-${topic_number}.md" | sed 's/^# *//')
              TITLE_LENGTH=${#RAW_TITLE}
              
              # Smart title handling - don't truncate, but warn if too long
              if [ $TITLE_LENGTH -gt 40 ]; then
                echo "âš ï¸ Title very long ($TITLE_LENGTH chars): $RAW_TITLE"
                # Extract a meaningful title from the raw title without brutal truncation
                TITLE=$(echo "$RAW_TITLE" | sed 's/ï¼š.*/ï¼šãã®çœŸæ„ã¯ï¼Ÿ/' | sed 's/ã€.*/ã®å¯èƒ½æ€§ã¨ã¯ï¼Ÿ/' | head -c 40)
                if [ ${#TITLE} -eq 40 ]; then
                  TITLE="${TITLE}ï¼Ÿ"
                fi
                echo "âœ‚ï¸ Smartly adjusted to: $TITLE"
              else
                TITLE="$RAW_TITLE"
                echo "âœ… Title length OK: $TITLE"
              fi
              
              # Ensure title ends properly (not with broken characters)
              if echo "$TITLE" | grep -E "[æ®µã‚¨ã¨ã‹ãŒã¦ã§ã«ã¯ã‚’ã®ã‚‚ã—ã¾ãŸã‚Š]$" >/dev/null; then
                TITLE=$(echo "$TITLE" | sed 's/[æ®µã‚¨ã¨ã‹ãŒã¦ã§ã«ã¯ã‚’ã®ã‚‚ã—ã¾ãŸã‚Š]$/ï¼Ÿ/')
                echo "ğŸ”§ Fixed broken title ending: $TITLE"
              fi
              
              # Create temp file with Jekyll format for duplicate checking
              TEMP_FILENAME="temp-$(date +%Y-%m-%d)-${topic_number}-$(date +%H%M).md"
              CURRENT_DATE="$(date +%Y-%m-%d\ %H:%M:%S\ %z)"
              EXCERPT_TEXT="$(echo "$TOPIC" | cut -c1-100)ã«ã¤ã„ã¦è©³ç´°ã«åˆ†æã—ã¾ã™ã€‚"
              
              # Analyze content for appropriate category and tags
              CONTENT=$(sed '/---END---/,$d' "_temp/raw-article-${topic_number}.md" | head -500 | tr '[:upper:]' '[:lower:]')
              
              # Determine category based on content analysis
              CATEGORY="æœ€æ–°å‹•å‘"  # default
              if echo "$CONTENT $TITLE" | grep -E "(æŠ•è³‡|å¸‚å ´|è³‡é‡‘èª¿é”|è©•ä¾¡é¡|roi|å„„ãƒ‰ãƒ«|å…†ãƒ‰ãƒ«)" >/dev/null; then
                CATEGORY="æŠ•è³‡åˆ†æ"
              elif echo "$CONTENT $TITLE" | grep -E "(æŠ€è¡“|ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£|api|sdk|ãƒ—ãƒ­ã‚°ãƒ©ãƒ |ã‚³ãƒ¼ãƒ‰|ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ |ãƒ¢ãƒ‡ãƒ«|å­¦ç¿’)" >/dev/null; then
                CATEGORY="æŠ€è¡“è§£èª¬"
              elif echo "$CONTENT $TITLE" | grep -E "(å®Ÿè£…|å°å…¥|æ´»ç”¨|äº‹ä¾‹|ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£|å±•é–‹|é©ç”¨|é‹ç”¨)" >/dev/null; then
                CATEGORY="å®Ÿè£…äº‹ä¾‹"
              elif echo "$CONTENT $TITLE" | grep -E "(ç ”ç©¶|è«–æ–‡|å­¦è¡“|å®Ÿé¨“|ãƒ‡ãƒ¼ã‚¿|çµæœ|æ¤œè¨¼|åˆ†æ)" >/dev/null; then
                CATEGORY="ç ”ç©¶è«–æ–‡"
              fi
              
              # Generate tags based on title and content analysis  
              TAGS='"AI", "æœ€æ–°ãƒ‹ãƒ¥ãƒ¼ã‚¹", "æŠ€è¡“å‹•å‘"'  # default tags
              
              # Primary company detection (check title first, then content)
              PRIMARY_COMPANY=""
              
              # Check title first for primary company mention
              if echo "$TITLE" | grep -i "openai\|gpt-5\|gpt-4\|chatgpt" >/dev/null; then
                PRIMARY_COMPANY="OpenAI"
              elif echo "$TITLE" | grep -i "google\|gemini\|deepmind\|ã‚°ãƒ¼ã‚°ãƒ«" >/dev/null; then
                PRIMARY_COMPANY="Google"
              elif echo "$TITLE" | grep -i "microsoft\|ãƒã‚¤ã‚¯ãƒ­ã‚½ãƒ•ãƒˆ\|azure\|copilot" >/dev/null; then
                PRIMARY_COMPANY="Microsoft"
              elif echo "$TITLE" | grep -i "nvidia\|ã‚¨ãƒŒãƒ“ãƒ‡ã‚£ã‚¢\|blackwell" >/dev/null; then
                PRIMARY_COMPANY="NVIDIA"
              elif echo "$TITLE" | grep -i "meta\|ãƒ¡ã‚¿\|facebook\|llama" >/dev/null; then
                PRIMARY_COMPANY="Meta"
              elif echo "$TITLE" | grep -i "amazon\|aws\|anthropic\|claude" >/dev/null; then
                PRIMARY_COMPANY="Amazon"
              elif echo "$TITLE" | grep -i "broadcom\|ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚³ãƒ " >/dev/null; then
                PRIMARY_COMPANY="Broadcom"
              elif echo "$TITLE" | grep -i "apple\|ã‚¢ãƒƒãƒ—ãƒ«\|siri" >/dev/null; then
                PRIMARY_COMPANY="Apple"
              fi
              
              # Add primary company tag
              if [ -n "$PRIMARY_COMPANY" ]; then
                TAGS="${TAGS}, \"$PRIMARY_COMPANY\""
              fi
              
              # Add secondary companies only if they appear prominently in title or are main focus
              if echo "$TITLE $CONTENT" | grep -c -i "openai\|gpt" | grep -q "[2-9]" && [ "$PRIMARY_COMPANY" != "OpenAI" ]; then
                TAGS="${TAGS}, \"OpenAI\""
              fi
              if echo "$TITLE $CONTENT" | grep -c -i "google\|gemini" | grep -q "[2-9]" && [ "$PRIMARY_COMPANY" != "Google" ]; then
                TAGS="${TAGS}, \"Google\""
              fi
              if echo "$TITLE $CONTENT" | grep -c -i "microsoft\|azure" | grep -q "[2-9]" && [ "$PRIMARY_COMPANY" != "Microsoft" ]; then
                TAGS="${TAGS}, \"Microsoft\""
              fi
              
              # Add topic-specific tags
              if echo "$CONTENT $TITLE" | grep -i "æŠ•è³‡\|è³‡é‡‘èª¿é”\|è©•ä¾¡é¡" >/dev/null; then
                TAGS="${TAGS}, \"æŠ•è³‡\""
              fi
              if echo "$CONTENT $TITLE" | grep -i "chip\|ãƒãƒƒãƒ—\|gpu\|tpu\|semiconductor" >/dev/null; then
                TAGS="${TAGS}, \"ãƒãƒƒãƒ—\""
              fi
              if echo "$CONTENT $TITLE" | grep -i "ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ\|agent\|è‡ªå‹•åŒ–" >/dev/null; then
                TAGS="${TAGS}, \"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ\""
              fi
              
              # Create temp article with frontmatter
              printf "%s\n" "---" > "_temp/$TEMP_FILENAME"
              printf "%s\n" "layout: post" >> "_temp/$TEMP_FILENAME"
              printf "title: \"%s\"\n" "$TITLE" >> "_temp/$TEMP_FILENAME"
              printf "date: %s\n" "$CURRENT_DATE" >> "_temp/$TEMP_FILENAME"
              printf "categories: [\"%s\"]\n" "$CATEGORY" >> "_temp/$TEMP_FILENAME"
              printf "tags: [%s]\n" "$TAGS" >> "_temp/$TEMP_FILENAME"
              printf "%s\n" 'author: "ALLFORCESç·¨é›†éƒ¨"' >> "_temp/$TEMP_FILENAME"
              printf "excerpt: \"%s\"\n" "$EXCERPT_TEXT" >> "_temp/$TEMP_FILENAME"
              printf "%s\n" "reading_time: 8" >> "_temp/$TEMP_FILENAME"
              printf "%s\n\n" "---" >> "_temp/$TEMP_FILENAME"
              
              # Add article content (excluding ---END--- marker)
              sed '/---END---/,$d' "_temp/raw-article-${topic_number}.md" >> "_temp/$TEMP_FILENAME"
              
              echo "âœ… Generated temp article: $TEMP_FILENAME"
              GENERATED_COUNT=$((GENERATED_COUNT + 1))
            else
              echo "âŒ Failed to generate article for topic $topic_number: $TOPIC"
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
            
          done
          
          echo "ğŸ“Š Article generation summary:"
          echo "   âœ… Generated: $GENERATED_COUNT articles"
          echo "   âŒ Failed: $FAILED_COUNT articles"
          
          if [ "$GENERATED_COUNT" -eq 0 ]; then
            echo "ğŸ’€ No articles were generated successfully!"
            exit 1
          fi

      # STAGE 2.5: Semantic Duplicate Detection & Publishing
      - name: Semantic duplicate detection and publishing
        run: |
          echo "ğŸ§  Running semantic duplicate detection..."
          
          # Helper function to generate semantic filename
          generate_semantic_filename() {
            local temp_file="$1"
            
            # Extract title and date from markdown file
            local title=$(grep '^title:' "$temp_file" | sed 's/^title: *//' | sed 's/^"//' | sed 's/"$//' | head -1)
            local date=$(grep '^date:' "$temp_file" | sed 's/^date: *//' | cut -d' ' -f1 | head -1)
            
            # Default values if not found
            if [ -z "$title" ]; then
              title="AI Article"
            fi
            
            if [ -z "$date" ]; then
              date=$(date +%Y-%m-%d)
            fi
            
            # Extract topic number from original filename for uniqueness
            local topic_num=$(basename "$temp_file" | sed 's/.*-\([0-9]\+\)-[0-9]\+\.md$/\1/' | head -c 1)
            if [ -z "$topic_num" ]; then
              topic_num="1"
            fi
            
            # Create slug from title with improved Japanese mapping
            local slug=$(echo "$title" | \
              # Specific pattern mappings for better SEO
              sed 's/Googleã¨Meta.*è¦‡æ¨©äº‰ã„.*/google-meta-ai-competition/gi' | \
              sed 's/GPT-5.*è¡æ’ƒ.*/gpt-5-impact/gi' | \
              sed 's/NVIDIA.*Blackwell.*/nvidia-blackwell/gi' | \
              sed 's/OpenAI.*è‡ªç¤¾.*ãƒãƒƒãƒ—.*/openai-custom-chip/gi' | \
              sed 's/Microsoft.*AI.*æŠ•è³‡.*/microsoft-ai-investment/gi' | \
              sed 's/ã‚¯ãƒ©ã‚¦ãƒ‰.*è¦‡æ¨©.*/cloud-ai-competition/gi' | \
              sed 's/é‡åŠ›æ³¢æ¤œå‡º.*AI.*/gravitational-wave-ai/gi' | \
              sed 's/Broadcom.*OpenAI.*/broadcom-openai-deal/gi' | \
              # General term replacements
              sed 's/äººå·¥çŸ¥èƒ½\|AIæŠ€è¡“/ai/gi' | \
              sed 's/æŠ•è³‡\|å¸‚å ´/market/gi' | \
              sed 's/æŠ€è¡“/tech/gi' | \
              sed 's/ä¼æ¥­/company/gi' | \
              sed 's/åˆ†æ/analysis/gi' | \
              sed 's/æœ€æ–°/latest/gi' | \
              sed 's/è¦‡æ¨©äº‰ã„\|ç«¶äº‰æ¿€åŒ–/competition/gi' | \
              sed 's/æ–°æ™‚ä»£/new-era/gi' | \
              sed 's/æœªæ¥.*åŠ é€Ÿ/future-acceleration/gi' | \
              # Company name mappings
              sed 's/ãƒã‚¤ã‚¯ãƒ­ã‚½ãƒ•ãƒˆ/microsoft/gi' | \
              sed 's/ã‚°ãƒ¼ã‚°ãƒ«/google/gi' | \
              sed 's/ã‚¨ãƒŒãƒ“ãƒ‡ã‚£ã‚¢/nvidia/gi' | \
              sed 's/ãƒ¡ã‚¿/meta/gi' | \
              sed 's/ã‚¢ãƒƒãƒ—ãƒ«/apple/gi' | \
              sed 's/ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚³ãƒ /broadcom/gi' | \
              # Clean up
              tr '[:upper:]' '[:lower:]' | \
              sed 's/[^a-z0-9]/-/g' | \
              sed 's/-\+/-/g' | \
              sed 's/^-\|-$//g' | \
              cut -c1-60)
            
            # Ensure slug is not empty or too short
            if [ -z "$slug" ] || [ "${#slug}" -lt 2 ]; then
              slug="ai-article"
            fi
            
            echo "${date}-${topic_num}-${slug}.md"
          }
          
          # Run semantic selector to filter duplicates and publish unique articles
          echo "ğŸ“‹ Temp articles available for duplicate checking:"
          ls -la _temp/temp-*.md || echo "No temp articles found!"
          
          if python3 scripts/semantic_selector.py; then
            echo "âœ… Semantic duplicate detection completed"
            
            # Count published articles
            TODAY=$(date +%Y-%m-%d)
            PUBLISHED_COUNT=$(find _posts -name "${TODAY}-*.md" -newer _temp/topics.txt 2>/dev/null | wc -l || echo "0")
            echo "ğŸ“Š Published $PUBLISHED_COUNT unique articles after duplicate detection"
            
            # If no articles were published due to duplicates, publish the most recent one anyway
            if [ "$PUBLISHED_COUNT" -eq 0 ]; then
              echo "âš ï¸ All articles were marked as duplicates. Publishing the newest one anyway..."
              NEWEST_TEMP=$(ls -t _temp/temp-*.md 2>/dev/null | head -1)
              if [ -n "$NEWEST_TEMP" ] && [ -f "$NEWEST_TEMP" ]; then
                final_name=$(generate_semantic_filename "$NEWEST_TEMP")
                if mv "$NEWEST_TEMP" "_posts/$final_name" 2>/dev/null; then
                  echo "âœ… Force-published newest article: $final_name"
                  PUBLISHED_COUNT=1
                fi
              fi
            fi
          else
            echo "âš ï¸ Semantic detection failed, proceeding with basic publishing..."
            
            # Fallback: move temp files directly to _posts
            FALLBACK_COUNT=0
            for temp_file in _temp/temp-*.md; do
              if [ -f "$temp_file" ]; then
                final_name=$(generate_semantic_filename "$temp_file")
                if mv "$temp_file" "_posts/$final_name" 2>/dev/null; then
                  echo "âœ… Published: $final_name"
                  FALLBACK_COUNT=$((FALLBACK_COUNT + 1))
                fi
              fi
            done
            echo "ğŸ“Š Published $FALLBACK_COUNT articles via fallback method"
          fi

      # STAGE 2.7: Article Completion Check
      - name: Check and complete incomplete articles
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          echo "ğŸ” Checking for incomplete articles..."
          python3 scripts/article_completion_checker.py _posts
          
          if [ -f "_temp/incomplete_articles.txt" ] && [ -s "_temp/incomplete_articles.txt" ]; then
            echo "ğŸ“‹ Found incomplete articles, attempting completion..."
            INCOMPLETE_COUNT=$(wc -l < _temp/incomplete_articles.txt)
            echo "Found $INCOMPLETE_COUNT incomplete articles"
            
            if [ "$INCOMPLETE_COUNT" -le 5 ] && [ -n "$GEMINI_API_KEY" ]; then
              echo "ğŸš€ Attempting automatic completion..."
              python3 scripts/article_completer.py
              
              # Re-check after completion
              python3 scripts/article_completion_checker.py _posts
              
              if [ -f "_temp/incomplete_articles.txt" ] && [ -s "_temp/incomplete_articles.txt" ]; then
                REMAINING_COUNT=$(wc -l < _temp/incomplete_articles.txt)
                echo "âš ï¸ $REMAINING_COUNT articles still incomplete after completion attempt"
              else
                echo "âœ… All articles completed successfully"
              fi
            else
              echo "âš ï¸ Too many incomplete articles ($INCOMPLETE_COUNT) or no API key - manual review needed"
            fi
          else
            echo "âœ… No incomplete articles found"
          fi

      # STAGE 3: Advanced Quality Enhancement
      - name: Advanced textlint quality enhancement
        run: |
          echo "âœï¸ Advanced quality enhancement..."
          
          # Process only today's articles
          TODAY=$(date +%Y-%m-%d)
          
          for article in _posts/${TODAY}-*.md; do
            if [ -f "$article" ]; then
              echo "ğŸ” Processing: $(basename "$article")"
              
              # 1. Basic textlint correction
              textlint --fix "$article" 2>/dev/null || true
              
              # 2. Remove AI expressions
              sed -i '/^AI ã«ã‚ˆã£ã¦/d' "$article"
              sed -i '/^ã“ã®è¨˜äº‹ã¯ AI/d' "$article"
              sed -i '/ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™/d' "$article"
              sed -i '/ã‚’è¦‹ã¦ã„ãã¾ã—ã‚‡ã†/d' "$article"
              sed -i '/ã„ã‹ãŒã§ã—ãŸã§ã—ã‚‡ã†ã‹/d' "$article"
              
              # 3. Enhance professionalism
              sed -i 's/å¤§å¹…ãª/300%ã®/g' "$article"
              sed -i 's/å¤šãã®ä¼æ¥­/75%ä»¥ä¸Šã®ä¼æ¥­/g' "$article"
              sed -i 's/é«˜ã„æˆé•·/å¹´ç‡25%ä»¥ä¸Šã®æˆé•·/g' "$article"
              
              # 4. Quality validation
              WORD_COUNT=$(wc -w < "$article")
              COMPANY_COUNT=$(grep -o 'OpenAI\|Google\|Microsoft\|Amazon\|NVIDIA\|Meta' "$article" | wc -l)
              NUMBER_COUNT=$(grep -o '[0-9]\+%\|[0-9]\+å„„\|[0-9]\+ä¸‡\|[0-9]\+ãƒ‰ãƒ«' "$article" | wc -l)
              
              echo "ğŸ“Š Quality metrics for $(basename "$article"):"
              echo "   Words: $WORD_COUNT"
              echo "   Companies mentioned: $COMPANY_COUNT"
              echo "   Numeric data: $NUMBER_COUNT"
              
              if [ $WORD_COUNT -lt 2000 ]; then
                echo "âš ï¸ Article may be too short"
              fi
              
              if [ $COMPANY_COUNT -lt 2 ]; then
                echo "âš ï¸ Insufficient company mentions"
              fi
              
              if [ $NUMBER_COUNT -lt 3 ]; then
                echo "âš ï¸ Insufficient numeric data"
              fi
              
              echo "âœ… Enhanced: $(basename "$article")"
            fi
          done

      - name: Setup Ruby and Jekyll
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: true
          cache-version: 1  # Increment this to invalidate cache if needed

      - name: Build and Deploy
        run: |
          bundle install
          bundle exec jekyll build

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './_site'

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4

      - name: Commit generated articles
        run: |
          echo "ğŸ“ Checking for new articles to commit..."
          
          if [ -n "$(git status --porcelain _posts/)" ]; then
            ARTICLE_COUNT=$(ls _posts/$(date +%Y-%m-%d)-*.md 2>/dev/null | wc -l)
            git add _posts/
            git commit -m "ğŸ¤– Add $ARTICLE_COUNT quality AI articles - $(date +%Y-%m-%d)"
            
            echo "ğŸ“¤ Pushing $ARTICLE_COUNT new articles..."
            if git push; then
              echo "âœ… Successfully pushed $ARTICLE_COUNT new articles"
            else
              echo "âŒ Push failed, attempting force push with lease..."
              git push --force-with-lease || exit 1
            fi
          else
            echo "â„¹ï¸ No new articles to commit"
          fi